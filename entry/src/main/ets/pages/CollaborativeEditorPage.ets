import { router } from '@kit.ArkUI'
import { ToolType } from '../model/ToolbarItem'
import { DrawingOperation, OperationType, CollaboratorInfo } from '../model/DrawingOperation'
import { HistoryManager } from '../utils/HistoryManager'
import { CollaborationManager } from '../utils/CollaborationManager'
import { EditorToolbar } from '../components/EditorToolbar'
import { ColorPicker } from '../components/ColorPicker'
import { BrushSettings } from '../components/BrushSettings'
import { CollaboratorCursor } from '../components/CollaboratorCursor'
import { WatermarkDialog } from '../components/WatermarkDialog'
import { WatermarkManager } from '../utils/WatermarkManager'
import { promptAction } from '@kit.ArkUI'
import { common } from '@kit.AbilityKit'

interface WatermarkParams {
  text: string;
  fontSize: number;
  fontColor: string;
  opacity: number;
  position: string;
}

// ÂçèÂêåÁºñËæëÂô®È°µÈù¢
@Entry
@Component
struct CollaborativeEditorPage {
  @State imageUri: string = ''
  @State sessionCode: string = ''
  @State userName: string = ''
  @State isHost: boolean = false
  @State selectedTool: ToolType = ToolType.NONE
  @State currentColor: string = '#000000'
  @State strokeWidth: number = 3
  @State brushOpacity: number = 1.0
  @State showColorPicker: boolean = false
  @State showBrushSettings: boolean = false
  @State operations: DrawingOperation[] = []
  @State collaborators: CollaboratorInfo[] = []
  @State showCollaborators: boolean = true
  @State canUndo: boolean = false
  @State canRedo: boolean = false

  private historyManager: HistoryManager = new HistoryManager()
  private canvasContext: CanvasRenderingContext2D | null = null
  private isDrawing: boolean = false
  private startX: number = 0
  private startY: number = 0
  private currentOperation: DrawingOperation | null = null
  private settings: RenderingContextSettings = new RenderingContextSettings(true)
  private myColor: string = '#FF0000'
  private collaboratorColors: string[] = ['#00FF00', '#0000FF', '#FFA500', '#800080', '#00FFFF']
  private collaborationManager: CollaborationManager = new CollaborationManager()
  private myUserId: string = ''
  private watermarkDialogController: CustomDialogController | null = null

  aboutToAppear() {
    // Ëé∑ÂèñË∑ØÁî±ÂèÇÊï∞
    const params = router.getParams() as Record<string, Object>
    if (params) {
      this.imageUri = (params['imageUri'] as string) || ''
      this.sessionCode = (params['sessionCode'] as string) || ''
      this.userName = (params['userName'] as string) || ''
      this.isHost = (params['isHost'] as boolean) || false
    }

    // ÁîüÊàêÁî®Êà∑ID
    this.myUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    // ÂàÜÈÖçÁî®Êà∑È¢úËâ≤
    this.myColor = this.collaboratorColors[Math.floor(Math.random() * this.collaboratorColors.length)]

    // ËøûÊé•ÂçèÂêåÁºñËæë‰ºöËØù
    this.connectToSession()
  }

  aboutToDisappear() {
    // Êñ≠ÂºÄËøûÊé•
    this.collaborationManager.disconnect()
  }

  // ËøûÊé•Âà∞ÂçèÂêåÁºñËæë‰ºöËØù
  async connectToSession() {
    // ËÆæÁΩÆÂõûË∞É
    this.collaborationManager.onOperationReceived = (operation: DrawingOperation) => {
      this.operations.push(operation)
      this.redrawCanvas()
    }

    this.collaborationManager.onCollaboratorJoined = (collaborator: CollaboratorInfo) => {
      this.collaborators.push(collaborator)
      promptAction.showToast({
        message: `${collaborator.userName} Âä†ÂÖ•‰∫ÜÁºñËæë`,
        duration: 2000
      })
    }

    this.collaborationManager.onCollaboratorLeft = (userId: string) => {
      const index = this.collaborators.findIndex(c => c.userId === userId)
      if (index >= 0) {
        const name = this.collaborators[index].userName
        this.collaborators.splice(index, 1)
        promptAction.showToast({
          message: `${name} Á¶ªÂºÄ‰∫ÜÁºñËæë`,
          duration: 2000
        })
      }
    }

    this.collaborationManager.onCursorMoved = (userId: string, x: number, y: number) => {
      const collaborator = this.collaborators.find(c => c.userId === userId)
      if (collaborator) {
        collaborator.cursorX = x
        collaborator.cursorY = y
      }
    }

    this.collaborationManager.onSyncReceived = (operations: DrawingOperation[]) => {
      this.operations = operations
      this.redrawCanvas()
    }

    this.collaborationManager.onError = (error: string) => {
      promptAction.showToast({
        message: 'ËøûÊé•Â§±Ë¥•ÔºåËØ∑ÈáçËØï',
        duration: 2000
      })
    }

    // ËøûÊé•
    const connected = await this.collaborationManager.connect(
      this.sessionCode,
      this.myUserId,
      this.userName,
      this.myColor
    )

    if (connected) {
      promptAction.showToast({
        message: 'Â∑≤Âä†ÂÖ•ÂçèÂêåÁºñËæë',
        duration: 2000
      })
    }
  }

  // Â§ÑÁêÜÂ∑•ÂÖ∑ÈÄâÊã©
  onToolSelected(tool: ToolType) {
    this.selectedTool = tool
    this.showColorPicker = false
    this.showBrushSettings = false

    if (tool === ToolType.PEN || tool === ToolType.LINE ||
      tool === ToolType.RECT || tool === ToolType.CIRCLE ||
      tool === ToolType.ELLIPSE || tool === ToolType.TEXT) {
      this.showColorPicker = true
      this.showBrushSettings = true
    } else if (tool === ToolType.ERASER) {
      this.showBrushSettings = true
    } else if (tool === ToolType.WATERMARK) {
      this.showWatermarkDialog()
    }
  }

  // ÊòæÁ§∫Ê∞¥Âç∞ÂØπËØùÊ°Ü
  showWatermarkDialog() {
    this.watermarkDialogController = new CustomDialogController({
      builder: WatermarkDialog({
        onConfirm: (params: WatermarkParams) => {
          this.addWatermark(params)
        }
      }),
      autoCancel: true,
      alignment: DialogAlignment.Center,
      customStyle: true
    })
    this.watermarkDialogController.open()
  }

  // Ê∑ªÂä†Ê∞¥Âç∞
  addWatermark(params: WatermarkParams) {
    if (!this.canvasContext) return

    let x = 0
    let y = 0

    // Ê†πÊçÆ‰ΩçÁΩÆËÆ°ÁÆóÂùêÊ†á
    switch (params.position) {
      case 'center':
        x = 400 - params.text.length * params.fontSize / 4
        y = 300 - params.fontSize / 2
        break
      case 'topLeft':
        x = 20
        y = 20
        break
      case 'topRight':
        x = 780 - params.text.length * params.fontSize / 2
        y = 20
        break
      case 'bottomLeft':
        x = 20
        y = 580 - params.fontSize
        break
      case 'bottomRight':
        x = 780 - params.text.length * params.fontSize / 2
        y = 580 - params.fontSize
        break
      case 'repeat':
        WatermarkManager.drawRepeatedWatermark(
          this.canvasContext,
          params.text,
          800,
          600,
          {
            fontSize: params.fontSize,
            fontColor: params.fontColor,
            opacity: params.opacity
          }
        )
        promptAction.showToast({
          message: 'Ê∞¥Âç∞Â∑≤Ê∑ªÂä†',
          duration: 2000
        })
        return
    }

    WatermarkManager.drawTextWatermark(
      this.canvasContext,
      params.text,
      x,
      y,
      {
        fontSize: params.fontSize,
        fontColor: params.fontColor,
        opacity: params.opacity
      }
    )

    promptAction.showToast({
      message: 'Ê∞¥Âç∞Â∑≤Ê∑ªÂä†',
      duration: 2000
    })
  }

  // Â§ÑÁêÜËß¶Êë∏ÂºÄÂßã
  handleTouchStart(event: TouchEvent) {
    if (this.selectedTool === ToolType.NONE) return

    this.isDrawing = true
    this.startX = event.touches[0].x
    this.startY = event.touches[0].y

    let opType = OperationType.DRAW_PATH
    switch (this.selectedTool) {
      case ToolType.PEN:
        opType = OperationType.DRAW_PATH
        break
      case ToolType.LINE:
        opType = OperationType.DRAW_LINE
        break
      case ToolType.RECT:
        opType = OperationType.DRAW_RECT
        break
      case ToolType.CIRCLE:
        opType = OperationType.DRAW_CIRCLE
        break
      case ToolType.ELLIPSE:
        opType = OperationType.DRAW_ELLIPSE
        break
      case ToolType.ERASER:
        opType = OperationType.ERASER
        break
    }

    this.currentOperation = new DrawingOperation(opType)
    this.currentOperation.color = this.currentColor
    this.currentOperation.strokeWidth = this.strokeWidth
    this.currentOperation.opacity = this.brushOpacity
    this.currentOperation.userName = this.userName
    this.currentOperation.userColor = this.myColor
    this.currentOperation.points.push({ x: this.startX, y: this.startY })
  }

  // Â§ÑÁêÜËß¶Êë∏ÁßªÂä®
  handleTouchMove(event: TouchEvent) {
    if (!this.isDrawing || !this.currentOperation) return

    const x = event.touches[0].x
    const y = event.touches[0].y

    if (this.selectedTool === ToolType.PEN || this.selectedTool === ToolType.ERASER) {
      this.currentOperation.points.push({ x, y })
    } else {
      if (this.currentOperation.points.length > 1) {
        this.currentOperation.points[1] = { x, y }
      } else {
        this.currentOperation.points.push({ x, y })
      }
    }

    // ÂπøÊí≠ÂÖâÊ†á‰ΩçÁΩÆÔºàÈôêÂà∂È¢ëÁéáÔºâ
    this.collaborationManager.broadcastCursorMove(x, y)

    this.redrawCanvas()
  }

  // Â§ÑÁêÜËß¶Êë∏ÁªìÊùü
  handleTouchEnd(event: TouchEvent) {
    if (!this.isDrawing || !this.currentOperation) return

    this.isDrawing = false

    this.historyManager.addOperation(this.currentOperation)
    this.operations.push(this.currentOperation)

    // ÂπøÊí≠ÁªòÂà∂ÂÆåÊàê‰∫ã‰ª∂
    const operation = this.currentOperation
    this.collaborationManager.broadcastOperation(operation)

    this.currentOperation = null
    this.updateUndoRedoState()
    this.redrawCanvas()
  }

  // ÈáçÁªòÁîªÂ∏É
  redrawCanvas() {
    if (!this.canvasContext) return

    this.canvasContext.clearRect(0, 0, 800, 600)

    // ÁªòÂà∂ÊâÄÊúâÊìç‰Ωú
    this.operations.forEach((op: DrawingOperation) => {
      this.drawOperation(op)
    })

    // ÁªòÂà∂ÂΩìÂâçÊìç‰Ωú
    if (this.currentOperation) {
      this.drawOperation(this.currentOperation)
    }
  }

  // ÁªòÂà∂Âçï‰∏™Êìç‰Ωú
  drawOperation(op: DrawingOperation) {
    if (!this.canvasContext || op.points.length === 0) return

    this.canvasContext.globalAlpha = op.opacity
    this.canvasContext.strokeStyle = op.color
    this.canvasContext.lineWidth = op.strokeWidth
    this.canvasContext.lineCap = 'round'
    this.canvasContext.lineJoin = 'round'

    if (op.type === OperationType.ERASER) {
      this.canvasContext.globalCompositeOperation = 'destination-out'
    } else {
      this.canvasContext.globalCompositeOperation = 'source-over'
    }

    this.canvasContext.beginPath()

    switch (op.type) {
      case OperationType.DRAW_PATH:
      case OperationType.ERASER:
        this.canvasContext.moveTo(op.points[0].x, op.points[0].y)
        for (let i = 1; i < op.points.length; i++) {
          this.canvasContext.lineTo(op.points[i].x, op.points[i].y)
        }
        this.canvasContext.stroke()
        break

      case OperationType.DRAW_LINE:
        if (op.points.length >= 2) {
          this.canvasContext.moveTo(op.points[0].x, op.points[0].y)
          this.canvasContext.lineTo(op.points[1].x, op.points[1].y)
          this.canvasContext.stroke()
        }
        break

      case OperationType.DRAW_RECT:
        if (op.points.length >= 2) {
          const width = op.points[1].x - op.points[0].x
          const height = op.points[1].y - op.points[0].y
          this.canvasContext.strokeRect(op.points[0].x, op.points[0].y, width, height)
        }
        break

      case OperationType.DRAW_CIRCLE:
        if (op.points.length >= 2) {
          const radius = Math.sqrt(
            Math.pow(op.points[1].x - op.points[0].x, 2) +
            Math.pow(op.points[1].y - op.points[0].y, 2)
          )
          this.canvasContext.arc(op.points[0].x, op.points[0].y, radius, 0, Math.PI * 2)
          this.canvasContext.stroke()
        }
        break

      case OperationType.DRAW_ELLIPSE:
        if (op.points.length >= 2) {
          const radiusX = Math.abs(op.points[1].x - op.points[0].x) / 2
          const radiusY = Math.abs(op.points[1].y - op.points[0].y) / 2
          const centerX = (op.points[0].x + op.points[1].x) / 2
          const centerY = (op.points[0].y + op.points[1].y) / 2
          this.canvasContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2)
          this.canvasContext.stroke()
        }
        break
    }

    this.canvasContext.globalAlpha = 1.0
    this.canvasContext.globalCompositeOperation = 'source-over'
  }

  // Êí§ÈîÄ
  undo() {
    const op = this.historyManager.undo()
    if (op) {
      this.operations.pop()
      this.updateUndoRedoState()
      this.redrawCanvas()
      // ÂπøÊí≠Êí§ÈîÄÊìç‰Ωú
      this.collaborationManager.broadcastUndo()
    }
  }

  // ÈáçÂÅö
  redo() {
    const op = this.historyManager.redo()
    if (op) {
      this.operations.push(op)
      this.updateUndoRedoState()
      this.redrawCanvas()
      // ÂπøÊí≠ÈáçÂÅöÊìç‰Ωú
      this.collaborationManager.broadcastRedo()
    }
  }

  // Êõ¥Êñ∞Êí§ÈîÄ/ÈáçÂÅöÁä∂ÊÄÅ
  updateUndoRedoState() {
    this.canUndo = this.historyManager.canUndo()
    this.canRedo = this.historyManager.canRedo()
  }

  // Â§çÂà∂‰ºöËØùÁ†Å
  copySessionCode() {
    // TODO: ÂÆûÁé∞Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø
    promptAction.showToast({
      message: `‰ºöËØùÁ†Å ${this.sessionCode} Â∑≤Â§çÂà∂`,
      duration: 2000
    })
  }

  build() {
    Column() {
      // È°∂ÈÉ®ÂØºËà™Ê†è
      Row() {
        Row({ space: 8 }) {
          Text('‚Üê')
            .fontSize(24)
            .fontColor('#1A1A1A')
            .onClick(() => {
              router.back()
            })

          Column({ space: 2 }) {
            Text('ÂçèÂêåÁºñËæë')
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor('#1A1A1A')

            Row({ space: 4 }) {
              Text(`‰ºöËØù: ${this.sessionCode}`)
                .fontSize(12)
                .fontColor('#666666')

              Text('üìã')
                .fontSize(12)
                .onClick(() => {
                  this.copySessionCode()
                })
            }
          }
          .alignItems(HorizontalAlign.Start)
        }

        Blank()

        Row({ space: 8 }) {
          // Âçè‰ΩúËÄÖÂ§¥ÂÉèÂàóË°®
          Row({ space: -8 }) {
            // ÊàëÁöÑÂ§¥ÂÉè
            Text(this.userName.charAt(0).toUpperCase())
              .fontSize(14)
              .fontColor('#FFFFFF')
              .fontWeight(FontWeight.Bold)
              .width(32)
              .height(32)
              .textAlign(TextAlign.Center)
              .backgroundColor(this.myColor)
              .borderRadius(16)
              .border({ width: 2, color: '#FFFFFF' })

            // ÂÖ∂‰ªñÂçè‰ΩúËÄÖ
            ForEach(this.collaborators, (collab: CollaboratorInfo) => {
              Text(collab.userName.charAt(0).toUpperCase())
                .fontSize(14)
                .fontColor('#FFFFFF')
                .fontWeight(FontWeight.Bold)
                .width(32)
                .height(32)
                .textAlign(TextAlign.Center)
                .backgroundColor(collab.userColor)
                .borderRadius(16)
                .border({ width: 2, color: '#FFFFFF' })
            })
          }

          Button('Êí§ÈîÄ')
            .fontSize(12)
            .height(28)
            .padding({ left: 8, right: 8 })
            .backgroundColor(this.canUndo ? '#007DFF' : '#E5E5E5')
            .fontColor(this.canUndo ? '#FFFFFF' : '#999999')
            .enabled(this.canUndo)
            .onClick(() => {
              this.undo()
            })
        }
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16 })
      .backgroundColor('#FFFFFF')
      .shadow({
        radius: 4,
        color: '#10000000',
        offsetY: 2
      })

      // ÁîªÂ∏ÉÂå∫Âüü
      Stack() {
        Column()
          .width('100%')
          .height('100%')
          .backgroundColor('#F0F0F0')

        // CanvasÁîªÂ∏É
        Canvas(this.canvasContext)
          .width('100%')
          .height('100%')
          .backgroundColor('#FFFFFF')
          .onReady(() => {
            this.canvasContext = new CanvasRenderingContext2D(this.settings)
            this.redrawCanvas()
          })
          .onTouch((event: TouchEvent) => {
            if (event.type === TouchType.Down) {
              this.handleTouchStart(event)
            } else if (event.type === TouchType.Move) {
              this.handleTouchMove(event)
            } else if (event.type === TouchType.Up) {
              this.handleTouchEnd(event)
            }
          })

        // Âçè‰ΩúËÄÖÂÖâÊ†á
        ForEach(this.collaborators, (collab: CollaboratorInfo) => {
          CollaboratorCursor({ collaborator: collab })
        })

        // ËÆæÁΩÆÈù¢Êùø
        if (this.showColorPicker || this.showBrushSettings) {
          Column({ space: 12 }) {
            if (this.showColorPicker) {
              ColorPicker({ selectedColor: $currentColor })
            }

            if (this.showBrushSettings) {
              BrushSettings({
                strokeWidth: $strokeWidth,
                brushOpacity: $brushOpacity
              })
            }
          }
          .padding(16)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .shadow({
            radius: 12,
            color: '#20000000',
            offsetY: 4
          })
          .margin(16)
          .alignSelf(ItemAlign.End)
        }

        // Âú®Á∫øÁî®Êà∑ÂàóË°®
        if (this.showCollaborators && this.collaborators.length > 0) {
          Column({ space: 8 }) {
            Text('Âú®Á∫øÂçè‰ΩúËÄÖ')
              .fontSize(12)
              .fontColor('#666666')
              .fontWeight(FontWeight.Medium)

            ForEach(this.collaborators, (collab: CollaboratorInfo) => {
              Row({ space: 8 }) {
                Circle({ width: 8, height: 8 })
                  .fill(collab.userColor)

                Text(collab.userName)
                  .fontSize(12)
                  .fontColor('#333333')

                if (collab.isDrawing) {
                  Text('ÁªòÂà∂‰∏≠...')
                    .fontSize(10)
                    .fontColor('#999999')
                }
              }
            })
          }
          .padding(12)
          .backgroundColor('#FFFFFF')
          .borderRadius(8)
          .shadow({
            radius: 8,
            color: '#20000000',
            offsetY: 2
          })
          .margin({ top: 16, left: 16 })
          .alignSelf(ItemAlign.Start)
        }
      }
      .layoutWeight(1)

      // Â∫ïÈÉ®Â∑•ÂÖ∑Ê†è
      EditorToolbar({
        selectedTool: $selectedTool,
        onToolSelected: (tool: ToolType) => {
          this.onToolSelected(tool)
        }
      })
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F5F5F5')
  }
}

