import { router } from '@kit.ArkUI'
import { ToolType } from '../model/ToolbarItem'
import { DrawingOperation, OperationType, ImageAdjustment } from '../model/DrawingOperation'
import { HistoryManager } from '../utils/HistoryManager'
import { EditorToolbar } from '../components/EditorToolbar'
import { CustomColorPicker } from '../components/ColorPicker'
import { BrushSettings } from '../components/BrushSettings'
import { ImageAdjustPanel } from '../components/ImageAdjustPanel'
import { CropPanel } from '../components/CropPanel'
import { WatermarkDialog } from '../components/WatermarkDialog'
import { ImageManager } from '../utils/ImageManager'
import { WatermarkManager } from '../utils/WatermarkManager'
import { ShareManager } from '../utils/ShareManager'
import { promptAction } from '@kit.ArkUI'
import { common } from '@kit.AbilityKit'
import { image } from '@kit.ImageKit'

// ------------------ ç±»å‹å®šä¹‰ä¸å£°æ˜ ------------------
interface WatermarkParams {
  text: string;
  fontSize: number;
  fontColor: string;
  opacity: number;
  position: string;
}

// CanvasElement ç±»å‹å®šä¹‰
interface CanvasElement {
  width: number;
  height: number;
}

// ArkUI ç¯å¢ƒä¸‹å¹¶æ— å†…ç½® Image å¯¹è±¡ï¼›ä¸ºé¿å… anyï¼Œå£°æ˜æœ€å°åŒ–æ¥å£å³å¯
declare class Image {
  src: string;
  width: number;
  height: number;
  onload: () => void;
  onerror: () => void;
}

// ---------------------------------------------------

// å›¾ç‰‡ç¼–è¾‘å™¨é¡µé¢
@Entry
@Component
struct EditorPage {
  @State imageUri: string = ''
  @State selectedTool: ToolType = ToolType.NONE
  @State currentColor: string = '#000000'
  @State strokeWidth: number = 3
  @State brushOpacity: number = 1.0
  @State showColorPicker: boolean = false
  @State showBrushSettings: boolean = false
  @State showAdjustPanel: boolean = false
  @State showCropPanel: boolean = false
  @State operations: DrawingOperation[] = []
  @State imageAdjustment: ImageAdjustment = new ImageAdjustment()
  @State imageBrightness: number = 0;  // æ˜¾å¼åˆå§‹åŒ–
  @State imageContrast: number = 0;    // æ˜¾å¼åˆå§‹åŒ–
  @State canUndo: boolean = false
  @State canRedo: boolean = false
  @State scaleFactor: number = 1.0
  @State offsetX: number = 0
  @State offsetY: number = 0
  @State cropX: number = 50
  @State cropY: number = 50
  @State cropWidth: number = 300
  @State cropHeight: number = 300
  @State showShareMenu: boolean = false
  @State imageLoaded: boolean = false
  @State canvasWidth: number = 800
  @State canvasHeight: number = 600
  private historyManager: HistoryManager = new HistoryManager()
  private canvasContext: CanvasRenderingContext2D | null = null
  private isDrawing: boolean = false
  private startX: number = 0
  private startY: number = 0
  private currentOperation: DrawingOperation | null = null
  private settings: RenderingContextSettings = new RenderingContextSettings(true)
  private loadedPixelMap: image.PixelMap | null = null
  private watermarkDialogController: CustomDialogController | null = null
  //@State imageBrightness: number = 0.5; // éœ€è¦æ˜¾å¼åˆå§‹åŒ–

  aboutToAppear() {
    // è·å–è·¯ç”±å‚æ•°
    const params = router.getParams() as Record<string, string>
    if (params && params['imageUri']) {
      this.imageUri = params['imageUri'] as string
      this.loadImage()
    }
  }

  // åŠ è½½å›¾ç‰‡
  async loadImage() {
    // 0. è¯»å–åª’ä½“æƒé™ï¼šAPI 20 å¤§å¤šå·²åœ¨æ¸…å•å£°æ˜åè‡ªåŠ¨æˆäºˆï¼Œå¦‚éœ€åŠ¨æ€ç”³è¯·å¯åœ¨æ­¤è¡¥å……
    if (!this.imageUri) {
      console.error('[EditorPage] loadImage - imageUri ä¸ºç©ºï¼Œç»ˆæ­¢åŠ è½½');
      return
    }

    try {
      console.log('[EditorPage] å°è¯•åˆ›å»º ImageSourceï¼ŒURI:', this.imageUri);
      // ä¸€äº›è®¾å¤‡/ç›¸å†Œè¿”å›çš„ file:// URI å¯èƒ½ä»…åŒ…å«ä¸¤ä¸ªæ–œæ ï¼Œå¯¼è‡´ ImageKit æ— æ³•è¯†åˆ«ï¼Œéœ€è¡¥å…¨ä¸º file:/// å½¢å¼
      let fixedUri: string = this.imageUri
      if (fixedUri.startsWith('file://') && !fixedUri.startsWith('file:///')) {
        fixedUri = 'file:///' + fixedUri.substring('file://'.length)
        console.warn(`[EditorPage] æ£€æµ‹åˆ° file:// URI ç¼ºå°‘æ ¹è·¯å¾„æ–œæ ï¼Œå·²ä¿®æ­£ä¸º: ${fixedUri}`)
      }

      // éƒ¨åˆ†ç³»ç»Ÿè¿”å›è·¯å¾„ç¼ºå°‘ /storage å‰ç¼€
      if (fixedUri.startsWith('file:///media/')) {
        fixedUri = fixedUri.replace('file:///media/', 'file:///storage/media/')
        console.warn(`[EditorPage] è¡¥å…¨å­˜å‚¨å‰ç¼€ï¼Œä¿®æ­£ä¸º: ${fixedUri}`)
      }

      const src = image.createImageSource(fixedUri)
      if (!src) {
        console.error('[EditorPage] 1.1 ImageSource åˆ›å»ºå¤±è´¥ï¼ˆè¿”å› nullï¼‰ï¼Œæ— æ³•ç»§ç»­');
        return;
      }
      console.log('[EditorPage] 2. ImageSource åˆ›å»ºæˆåŠŸï¼Œå‡†å¤‡åˆ›å»º PixelMap');
      const pixelMap = await src.createPixelMap()
      // å…³é”®ï¼šæ£€æŸ¥ PixelMap æ˜¯å¦æœ‰æ•ˆ
      if (!pixelMap) {
        console.error('[EditorPage] 3.1 PixelMap åˆ›å»ºå¤±è´¥ï¼ˆè¿”å› nullï¼‰ï¼Œæ— æ³•ç»§ç»­');
        return;
      }
      console.log('[EditorPage] 3. PixelMap åˆ›å»ºæˆåŠŸ');
      const info = await src.getImageInfo()
      console.log('[EditorPage] 5. å›¾ç‰‡ä¿¡æ¯è·å–æˆåŠŸï¼š', info);
      this.imageLoaded = true
      this.canvasWidth = info.size.width
      this.canvasHeight = info.size.height
      // ä¿å­˜ PixelMap ä»¥å¤‡ drawImage
      this.loadedPixelMap = pixelMap
      this.redrawCanvas()
      console.log('[EditorPage] 6. å›¾ç‰‡åŠ è½½å®Œæˆï¼Œè§¦å‘ redrawCanvas');
    } catch (err) {
      console.error('åŠ è½½å›¾ç‰‡å¤±è´¥:', JSON.stringify(err))
    }
  }

  // å¤„ç†å·¥å…·é€‰æ‹©
  onToolSelected(tool: ToolType) {
    this.selectedTool = tool
    this.showColorPicker = false
    this.showBrushSettings = false
    this.showAdjustPanel = false
    this.showCropPanel = false

    // æ ¹æ®å·¥å…·æ˜¾ç¤ºä¸åŒé¢æ¿
    if (tool === ToolType.PEN || tool === ToolType.LINE ||
      tool === ToolType.RECT || tool === ToolType.CIRCLE ||
      tool === ToolType.ELLIPSE || tool === ToolType.TEXT) {
      this.showColorPicker = true
      this.showBrushSettings = true
    } else if (tool === ToolType.BRIGHTNESS || tool === ToolType.ROTATE) {
      this.showAdjustPanel = true
    } else if (tool === ToolType.ERASER) {
      this.showBrushSettings = true
    } else if (tool === ToolType.CROP) {
      this.showCropPanel = true
    } else if (tool === ToolType.WATERMARK) {
      this.showWatermarkDialog()
    }
  }

  // æ˜¾ç¤ºæ°´å°å¯¹è¯æ¡†
  showWatermarkDialog() {
    this.watermarkDialogController = new CustomDialogController({
      builder: WatermarkDialog({
        onConfirm: (params: WatermarkParams) => {
          this.addWatermark(params)
        }
      }),
      autoCancel: true,
      alignment: DialogAlignment.Center,
      customStyle: true
    })
    this.watermarkDialogController.open()
  }

  // æ·»åŠ æ°´å°
  addWatermark(params: WatermarkParams) {
    if (!this.canvasContext) {
      return
    }

    let x = 0
    let y = 0

    // æ ¹æ®ä½ç½®è®¡ç®—åæ ‡
    switch (params.position) {
      case 'center':
        x = this.canvasWidth / 2 - params.text.length * params.fontSize / 4
        y = this.canvasHeight / 2 - params.fontSize / 2
        break
      case 'topLeft':
        x = 20
        y = 20
        break
      case 'topRight':
        x = this.canvasWidth - params.text.length * params.fontSize / 2 - 20
        y = 20
        break
      case 'bottomLeft':
        x = 20
        y = this.canvasHeight - params.fontSize - 20
        break
      case 'bottomRight':
        x = this.canvasWidth - params.text.length * params.fontSize / 2 - 20
        y = this.canvasHeight - params.fontSize - 20
        break
      case 'repeat':
        WatermarkManager.drawRepeatedWatermark(
          this.canvasContext,
          params.text,
          this.canvasWidth,
          this.canvasHeight,
          {
            fontSize: params.fontSize,
            fontColor: params.fontColor,
            opacity: params.opacity
          }
        )
        promptAction.showToast({
          message: 'æ°´å°å·²æ·»åŠ ',
          duration: 2000
        })
        return
    }

    WatermarkManager.drawTextWatermark(
      this.canvasContext,
      params.text,
      x,
      y,
      {
        fontSize: params.fontSize,
        fontColor: params.fontColor,
        opacity: params.opacity
      }
    )

    promptAction.showToast({
      message: 'æ°´å°å·²æ·»åŠ ',
      duration: 2000
    })
  }

  // ç¡®è®¤è£å‰ª
  confirmCrop() {
    // åˆ›å»ºæ–°çš„canvasä¿å­˜è£å‰ªç»“æœ
    if (!this.canvasContext) {
      return
    }

    const imageData = this.canvasContext.getImageData(
      this.cropX,
      this.cropY,
      this.cropWidth,
      this.cropHeight
    )
    // æ¸…ç©ºå¹¶è°ƒæ•´canvaså¤§å°
    this.canvasWidth = this.cropWidth
    this.canvasHeight = this.cropHeight

    // ç»˜åˆ¶è£å‰ªåçš„å›¾ç‰‡
    this.canvasContext.putImageData(imageData, 0, 0)

    this.showCropPanel = false
    this.selectedTool = ToolType.NONE

    promptAction.showToast({
      message: 'è£å‰ªå®Œæˆ',
      duration: 2000
    })
  }

  // å–æ¶ˆè£å‰ª
  cancelCrop() {
    this.showCropPanel = false
    this.selectedTool = ToolType.NONE
  }

  // å¤„ç†è§¦æ‘¸å¼€å§‹
  handleTouchStart(event: TouchEvent) {
    if (this.selectedTool === ToolType.NONE) {
      return
    }

    this.isDrawing = true
    this.startX = event.touches[0].x
    this.startY = event.touches[0].y

    // åˆ›å»ºæ–°æ“ä½œ
    let opType = OperationType.DRAW_PATH
    switch (this.selectedTool) {
      case ToolType.PEN:
        opType = OperationType.DRAW_PATH
        break
      case ToolType.LINE:
        opType = OperationType.DRAW_LINE
        break
      case ToolType.RECT:
        opType = OperationType.DRAW_RECT
        break
      case ToolType.CIRCLE:
        opType = OperationType.DRAW_CIRCLE
        break
      case ToolType.ELLIPSE:
        opType = OperationType.DRAW_ELLIPSE
        break
      case ToolType.ERASER:
        opType = OperationType.ERASER
        break
    }

    this.currentOperation = new DrawingOperation(opType)
    this.currentOperation.color = this.currentColor
    this.currentOperation.strokeWidth = this.strokeWidth
    this.currentOperation.opacity = this.brushOpacity
    this.currentOperation.points.push({ x: this.startX, y: this.startY })
  }

  // å¤„ç†è§¦æ‘¸ç§»åŠ¨
  handleTouchMove(event: TouchEvent) {
    if (!this.isDrawing || !this.currentOperation) {
      return
    }

    const x = event.touches[0].x
    const y = event.touches[0].y

    if (this.selectedTool === ToolType.PEN || this.selectedTool === ToolType.ERASER) {
      // è‡ªç”±ç»˜åˆ¶
      this.currentOperation.points.push({ x, y })
    } else {
      // å½¢çŠ¶ç»˜åˆ¶ï¼Œæ›´æ–°ç»ˆç‚¹
      if (this.currentOperation.points.length > 1) {
        this.currentOperation.points[1] = { x, y }
      } else {
        this.currentOperation.points.push({ x, y })
      }
    }

    this.redrawCanvas()
  }

  // å¤„ç†è§¦æ‘¸ç»“æŸ
  handleTouchEnd(event: TouchEvent) {
    if (!this.isDrawing || !this.currentOperation) {
      return
    }

    this.isDrawing = false

    // æ·»åŠ åˆ°å†å²è®°å½•
    this.historyManager.addOperation(this.currentOperation)
    this.operations.push(this.currentOperation)
    this.currentOperation = null

    this.updateUndoRedoState()
    this.redrawCanvas()
  }

  // é‡ç»˜ç”»å¸ƒ
  redrawCanvas() {
    console.log('[EditorPage] redrawCanvas - å¼€å§‹é‡ç»˜ç”»å¸ƒ');
    if (!this.canvasContext) {
      console.error('[EditorPage] redrawCanvas - canvasContext ä¸º nullï¼Œæ— æ³•ç»˜åˆ¶');
      return
    }

    // æ¸…ç©ºç”»å¸ƒ
    this.canvasContext.clearRect(0, 0, this.canvasWidth, this.canvasHeight)
    console.log(`[EditorPage] æ¸…ç©ºç”»å¸ƒï¼šå®½=${this.canvasWidth}, é«˜=${this.canvasHeight}`);

    // ç»˜åˆ¶å›¾ç‰‡
    if (this.loadedPixelMap) {
      console.log('[EditorPage] å¼€å§‹ç»˜åˆ¶å›¾ç‰‡åˆ°ç”»å¸ƒ');
      // Canvas ç›®å‰æ”¯æŒ drawImage(PixelMap, x, y, w?, h?)
      this.canvasContext.drawImage(this.loadedPixelMap, 0, 0, this.canvasWidth, this.canvasHeight)
      console.log('[EditorPage] å›¾ç‰‡ç»˜åˆ¶å®Œæˆ');
    }

    // åº”ç”¨å›¾ç‰‡è°ƒæ•´ï¼ˆäº®åº¦ã€å¯¹æ¯”åº¦ã€æ—‹è½¬ï¼‰
    if (this.imageAdjustment.imageBrightness !== 0 || this.imageAdjustment.imageContrast !== 0) {
      this.applyImageAdjustments()
    }

    // ç»˜åˆ¶æ‰€æœ‰æ“ä½œ
    this.operations.forEach((op: DrawingOperation) => {
      this.drawOperation(op)
    })

    // ç»˜åˆ¶å½“å‰æ“ä½œ
    if (this.currentOperation) {
      this.drawOperation(this.currentOperation)
    }

    // ç»˜åˆ¶è£å‰ªæ¡†
    if (this.showCropPanel) {
      this.drawCropOverlay()
    }
  }

  // åº”ç”¨å›¾ç‰‡è°ƒæ•´
  applyImageAdjustments() {
    if (!this.canvasContext) {
      return
    }

    const imageData = this.canvasContext.getImageData(0, 0, this.canvasWidth, this.canvasHeight)
    const data = imageData.data

    const brightness = this.imageAdjustment.imageBrightness * 2.55 // è½¬æ¢ä¸º0-255èŒƒå›´
    const contrast = (this.imageAdjustment.imageContrast + 100) / 100 // è½¬æ¢ä¸ºä¹˜æ•°

    for (let i = 0; i < data.length; i += 4) {
      // åº”ç”¨å¯¹æ¯”åº¦
      data[i] = (data[i] - 128) * contrast + 128 // R
      data[i + 1] = (data[i + 1] - 128) * contrast + 128 // G
      data[i + 2] = (data[i + 2] - 128) * contrast + 128 // B

      // åº”ç”¨äº®åº¦
      data[i] += brightness // R
      data[i + 1] += brightness // G
      data[i + 2] += brightness // B

      // é™åˆ¶åœ¨0-255èŒƒå›´å†…
      data[i] = Math.max(0, Math.min(255, data[i]))
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1]))
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2]))
    }

    this.canvasContext.putImageData(imageData, 0, 0)
  }

  // ç»˜åˆ¶è£å‰ªæ¡†
  drawCropOverlay() {
    if (!this.canvasContext) {
      return
    }

    this.canvasContext.save()

    // ç»˜åˆ¶åŠé€æ˜é®ç½©
    this.canvasContext.fillStyle = 'rgba(0, 0, 0, 0.5)'
    this.canvasContext.fillRect(0, 0, this.canvasWidth, this.canvasHeight)

    // æ¸…é™¤è£å‰ªåŒºåŸŸ
    this.canvasContext.clearRect(this.cropX, this.cropY, this.cropWidth, this.cropHeight)

    // ç»˜åˆ¶è£å‰ªæ¡†è¾¹æ¡†
    this.canvasContext.strokeStyle = '#007DFF'
    this.canvasContext.lineWidth = 2
    this.canvasContext.strokeRect(this.cropX, this.cropY, this.cropWidth, this.cropHeight)

    // ç»˜åˆ¶ä¹å®«æ ¼å‚è€ƒçº¿
    this.canvasContext.strokeStyle = '#FFFFFF'
    this.canvasContext.lineWidth = 1
    this.canvasContext.setLineDash([5, 5])

    // å‚ç›´çº¿
    this.canvasContext.beginPath()
    this.canvasContext.moveTo(this.cropX + this.cropWidth / 3, this.cropY)
    this.canvasContext.lineTo(this.cropX + this.cropWidth / 3, this.cropY + this.cropHeight)
    this.canvasContext.moveTo(this.cropX + this.cropWidth * 2 / 3, this.cropY)
    this.canvasContext.lineTo(this.cropX + this.cropWidth * 2 / 3, this.cropY + this.cropHeight)
    this.canvasContext.stroke()

    // æ°´å¹³çº¿
    this.canvasContext.beginPath()
    this.canvasContext.moveTo(this.cropX, this.cropY + this.cropHeight / 3)
    this.canvasContext.lineTo(this.cropX + this.cropWidth, this.cropY + this.cropHeight / 3)
    this.canvasContext.moveTo(this.cropX, this.cropY + this.cropHeight * 2 / 3)
    this.canvasContext.lineTo(this.cropX + this.cropWidth, this.cropY + this.cropHeight * 2 / 3)
    this.canvasContext.stroke()

    this.canvasContext.restore()
  }

  // ç»˜åˆ¶å•ä¸ªæ“ä½œ
  drawOperation(op: DrawingOperation) {
    if (!this.canvasContext || op.points.length === 0) {
      return
    }

    this.canvasContext.globalAlpha = op.opacity
    this.canvasContext.strokeStyle = op.color
    this.canvasContext.lineWidth = op.strokeWidth
    this.canvasContext.lineCap = 'round'
    this.canvasContext.lineJoin = 'round'

    if (op.type === OperationType.ERASER) {
      this.canvasContext.globalCompositeOperation = 'destination-out'
    } else {
      this.canvasContext.globalCompositeOperation = 'source-over'
    }

    this.canvasContext.beginPath()

    switch (op.type) {
      case OperationType.DRAW_PATH:
      case OperationType.ERASER:
        // è‡ªç”±è·¯å¾„
        this.canvasContext.moveTo(op.points[0].x, op.points[0].y)
        for (let i = 1; i < op.points.length; i++) {
          this.canvasContext.lineTo(op.points[i].x, op.points[i].y)
        }
        this.canvasContext.stroke()
        break

      case OperationType.DRAW_LINE:
        // ç›´çº¿
        if (op.points.length >= 2) {
          this.canvasContext.moveTo(op.points[0].x, op.points[0].y)
          this.canvasContext.lineTo(op.points[1].x, op.points[1].y)
          this.canvasContext.stroke()
        }
        break

      case OperationType.DRAW_RECT:
        // çŸ©å½¢
        if (op.points.length >= 2) {
          const width = op.points[1].x - op.points[0].x
          const height = op.points[1].y - op.points[0].y
          this.canvasContext.strokeRect(op.points[0].x, op.points[0].y, width, height)
        }
        break

      case OperationType.DRAW_CIRCLE:
        // åœ†å½¢
        if (op.points.length >= 2) {
          const radius = Math.sqrt(
            Math.pow(op.points[1].x - op.points[0].x, 2) +
            Math.pow(op.points[1].y - op.points[0].y, 2)
          )
          this.canvasContext.arc(op.points[0].x, op.points[0].y, radius, 0, Math.PI * 2)
          this.canvasContext.stroke()
        }
        break

      case OperationType.DRAW_ELLIPSE:
        // æ¤­åœ†
        if (op.points.length >= 2) {
          const radiusX = Math.abs(op.points[1].x - op.points[0].x) / 2
          const radiusY = Math.abs(op.points[1].y - op.points[0].y) / 2
          const centerX = (op.points[0].x + op.points[1].x) / 2
          const centerY = (op.points[0].y + op.points[1].y) / 2
          this.canvasContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2)
          this.canvasContext.stroke()
        }
        break
    }

    this.canvasContext.globalAlpha = 1.0
    this.canvasContext.globalCompositeOperation = 'source-over'
  }

  // æ’¤é”€
  undo() {
    const op = this.historyManager.undo()
    if (op) {
      this.operations.pop()
      this.updateUndoRedoState()
      this.redrawCanvas()
    }
  }

  // é‡åš
  redo() {
    const op = this.historyManager.redo()
    if (op) {
      this.operations.push(op)
      this.updateUndoRedoState()
      this.redrawCanvas()
    }
  }

  // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
  updateUndoRedoState() {
    this.canUndo = this.historyManager.canUndo()
    this.canRedo = this.historyManager.canRedo()
  }

  // æ—‹è½¬å›¾ç‰‡
  rotateImage() {
    this.imageAdjustment.rotation = (this.imageAdjustment.rotation + 90) % 360
    this.redrawCanvas()
  }

  // ä¿å­˜å›¾ç‰‡
  async saveImage() {
    if (!this.canvasContext) {
      promptAction.showToast({
        message: 'æ²¡æœ‰å¯ä¿å­˜çš„å†…å®¹',
        duration: 2000
      })
      return
    }
    try {
      // è·å–canvasçš„ImageData
      const imageData = this.canvasContext.getImageData(0, 0, this.canvasWidth, this.canvasHeight)

      // å®é™…åº”ç”¨ä¸­éœ€è¦å°†ImageDataè½¬æ¢ä¸ºPixelMapå¹¶ä¿å­˜
      // è¿™é‡Œç®€åŒ–å¤„ç†
      promptAction.showToast({
        message: 'å›¾ç‰‡å·²ä¿å­˜åˆ°ç›¸å†Œ',
        duration: 2000
      })
    } catch (err) {
      console.error('ä¿å­˜å¤±è´¥:', JSON.stringify(err))
      promptAction.showToast({
        message: 'ä¿å­˜å¤±è´¥',
        duration: 2000
      })
    }
  }

  // åˆ†äº«å›¾ç‰‡
  async shareImage() {
    this.showShareMenu = !this.showShareMenu
  }

  // åˆ†äº«åˆ°æŒ‡å®šå¹³å°
  async shareToApp(appName: string) {
    this.showShareMenu = false

    try {
      const context = getContext(this) as common.UIAbilityContext
      await ShareManager.shareToApp(this.imageUri, appName, context)
    } catch (err) {
      console.error('åˆ†äº«å¤±è´¥:', JSON.stringify(err))
      promptAction.showToast({
        message: 'åˆ†äº«å¤±è´¥',
        duration: 2000
      })
    }
  }

  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ 
      Row() {
        Row({ space: 8 }) {
          Text('â†')
            .fontSize(24)
            .fontColor('#1A1A1A')
            .onClick(() => {
              router.back()
            })

          Text('ç¼–è¾‘å›¾ç‰‡')
            .fontSize(18)
            .fontWeight(FontWeight.Medium)
            .fontColor('#1A1A1A')
        }

        Blank()

        Row({ space: 12 }) {
          Button('æ’¤é”€')
            .fontSize(14)
            .height(32)
            .backgroundColor(this.canUndo ? '#007DFF' : '#E5E5E5')
            .fontColor(this.canUndo ? '#FFFFFF' : '#999999')
            .enabled(this.canUndo)
            .onClick(() => {
              this.undo()
            })

          Button('é‡åš')
            .fontSize(14)
            .height(32)
            .backgroundColor(this.canRedo ? '#007DFF' : '#E5E5E5')
            .fontColor(this.canRedo ? '#FFFFFF' : '#999999')
            .enabled(this.canRedo)
            .onClick(() => {
              this.redo()
            })

          Button('åˆ†äº«')
            .fontSize(14)
            .height(32)
            .backgroundColor('#52C41A')
            .onClick(() => {
              this.shareImage()
            })
        }
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16 })
      .backgroundColor('#FFFFFF')
      .shadow({
        radius: 4,
        color: '#10000000',
        offsetY: 2
      })

      // ç”»å¸ƒåŒºåŸŸ
      Stack() {
        // èƒŒæ™¯
        Column()
          .width('100%')
          .height('100%')
          .backgroundColor('#F0F0F0')

        // Canvasç”»å¸ƒ
        Canvas(this.canvasContext)
          .width('100%')
          .height('100%')
          .backgroundColor('#FFFFFF')
          .onReady(() => {
            this.canvasContext = new CanvasRenderingContext2D(this.settings)
            this.redrawCanvas()
          })
          .onTouch((event: TouchEvent) => {
            if (event.type === TouchType.Down) {
              this.handleTouchStart(event)
            } else if (event.type === TouchType.Move) {
              this.handleTouchMove(event)
            } else if (event.type === TouchType.Up) {
              this.handleTouchEnd(event)
            }
          })

        // è®¾ç½®é¢æ¿
        if (this.showColorPicker || this.showBrushSettings || this.showAdjustPanel) {
          //const color = this.currentColor;
          Column({ space: 12 }) {
            if (this.showColorPicker) {
              CustomColorPicker({ selectedColor: this.currentColor })
            }

            if (this.showBrushSettings) {
              BrushSettings({
                strokeWidth: $strokeWidth,
                brushOpacity: $brushOpacity
              })
            }

            if (this.showAdjustPanel) {
              ImageAdjustPanel({
                // imageBrightness: this.imageAdjustment.imageBrightness,
                // imageContrast: this.imageAdjustment.imageContrast,
                imageBrightness: $imageBrightness,  // æ³¨æ„ï¼šåŒå‘ç»‘å®šéœ€ç”¨$è¯­æ³•ä¼ é€’
                imageContrast: $imageContrast,
                onRotate: () => {
                  this.rotateImage()
                }
              })
            }
          }
          .padding(16)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .shadow({
            radius: 12,
            color: '#20000000',
            offsetY: 4
          })
          .margin(16)
          .alignSelf(ItemAlign.End)
        }

        // è£å‰ªé¢æ¿
        if (this.showCropPanel) {
          CropPanel({
            cropX: $cropX,
            cropY: $cropY,
            cropWidth: $cropWidth,
            cropHeight: $cropHeight,
            onConfirm: () => {
              this.confirmCrop()
            },
            onCancel: () => {
              this.cancelCrop()
            }
          })
            .margin(16)
            .alignSelf(ItemAlign.Center)
        }

        // åˆ†äº«èœå•
        if (this.showShareMenu) {
          Column({ space: 12 }) {
            Text('åˆ†äº«åˆ°')
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor('#333333')

            Column({ space: 8 }) {
              this.ShareMenuItem('å¾®ä¿¡', 'ğŸ“±', () => {
                this.shareToApp('wechat')
              })
              this.ShareMenuItem('å¾®åš', 'ğŸ“·', () => {
                this.shareToApp('weibo')
              })
              this.ShareMenuItem('QQ', 'ğŸ’¬', () => {
                this.shareToApp('qq')
              })
              this.ShareMenuItem('é‚®ä»¶', 'ğŸ“§', () => {
                this.shareToApp('email')
              })
              this.ShareMenuItem('ä¿å­˜åˆ°ç›¸å†Œ', 'ğŸ’¾', () => {
                this.saveImage()
                this.showShareMenu = false
              })
            }
          }
          .padding(16)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .shadow({
            radius: 12,
            color: '#20000000',
            offsetY: 4
          })
          .margin(16)
          .position({ x: '50%', y: '50%' })
          .translate({ x: '-50%', y: '-50%' })
        }
      }
      .layoutWeight(1)

      // åº•éƒ¨å·¥å…·æ 
      EditorToolbar({
        selectedTool: $selectedTool,
        onToolSelected: (tool: ToolType) => {
          this.onToolSelected(tool)
        }
      })
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F5F5F5')
  }

  // åˆ†äº«èœå•é¡¹
  @Builder
  ShareMenuItem(title: string, icon: string, action: () => void) {
    Row({ space: 12 }) {
      Text(icon)
        .fontSize(24)

      Text(title)
        .fontSize(16)
        .fontColor('#333333')
        .layoutWeight(1)

      Text('â†’')
        .fontSize(18)
        .fontColor('#999999')
    }
    .width('100%')
    .height(48)
    .padding({ left: 12, right: 12 })
    .backgroundColor('#F5F5F5')
    .borderRadius(8)
    .onClick(() => {
      action()
    })
  }
}

